#load @"c:\Users\Tomas\Scripts\Paket\LoadPackages.fsx"
#r @"c:\Users\Tomas\OneDrive\OneSync\Projects\CommonTools\CommonTools\bin\Release\CommonTools.dll"

open MathNet.Numerics.Distributions
open CommonTools.RInterop
open FSharp.Charting

// Fixed model paremeter values
// These are the "real" model parameters that we want to infer.
// The values are used to create the measured data that inputs the Bayesian inference.
let muTheta = 10.0
let sigmaTheta = 0.2
let sigmaY = 0.05 // Measurement error

// Limits for the parameters
// These values serves in the Bayesian model as the liminst in the uniform prior distributions.
let minMuTheta, maxMuTheta = 5.0, 20.0
let minSigmaTheta, maxSigmaTheta = 0.05, 1.0
let minSigmaY, maxSigmaY = 0.02, 0.08

// Data counts
let numThetaSamples = 1000
let numYForOneTheta = 1 // Dvakrat mer

let samplesTheta = Normal.Samples(muTheta, sigmaTheta) |> Seq.take numThetaSamples
let modelFunc theta = theta + theta * theta
let sampleY muY = Normal.Samples(muY, sigmaY) |> Seq.take numYForOneTheta



// Generate samples of Y
let ys = samplesTheta |> Seq.map modelFunc |> Seq.map sampleY |> Seq.collect id |> Seq.toList
let indicator = [for i in [1..numThetaSamples] do for j in [1..numYForOneTheta] do yield i]

// Save to R file
let fileName = @"C:\Users\Tomas\Sync\Anicka\model-data.R"
let RData =
  [
    RFloatVector("ys", ys)
    RFloatVector("samplesTheta", samplesTheta |> Seq.toList)
    RIntVector("indicator", indicator)
    RIntScalar("numThetaSamples", numThetaSamples)
    RIntScalar("numYForOneTheta", numYForOneTheta)
    RFloatScalar("minMuTheta", minMuTheta)
    RFloatScalar("maxMuTheta", maxMuTheta)
    RFloatScalar("minSigmaTheta", minSigmaTheta)
    RFloatScalar("maxSigmaTheta", maxSigmaTheta)
    RFloatScalar("minSigmaY", minSigmaY)
    RFloatScalar("maxSigmaY", maxSigmaY)
  ] |> CommonTools.RInterop.toRData
do CommonTools.IO.writeLines fileName [RData]


// RUN JAGS
let runJAGS() =
  let p = new System.Diagnostics.Process()
  p.StartInfo.FileName <- "jags.bat"
  p.StartInfo.Arguments <- @"c:\Users\Tomas\Sync\Anicka\test1.cmd"
  p.StartInfo.WorkingDirectory <- @"c:\Users\Tomas\Sync\Anicka\"
  p.StartInfo.UseShellExecute <- false
  p.StartInfo.RedirectStandardOutput <- true
  // Start the process
  if not (p.Start()) then failwith "Process did not start."
  // Read output
  let output = p.StandardOutput.ReadToEnd()
  p.WaitForExit()
  // Write output to console
  System.Console.WriteLine("Output:");
  System.Console.WriteLine(output);  

do runJAGS()



// CODA chain analysis
// This require the CODA output files generated by JAGS the in the BeamEG directory.
let indexFile = @"c:\Users\Tomas\Sync\Anicka\CODAindex.txt" 
let chain1File = @"c:\Users\Tomas\Sync\Anicka\CODAchain1.txt" 
let chain2File = @"c:\Users\Tomas\Sync\Anicka\CODAchain2.txt" 

let chains =
  let getChains chainFile = 
    // Parsed CODA index file. Each entry contains variable name and from-to indexes in the CODA chain.
    let monitoredQuantitiesBounds =
      CommonTools.IO.readLines indexFile |> Seq.map (fun line -> line.Split([|' '|]) |> List.ofArray)
      |> List.ofSeq |> List.map (fun l -> (l.[0], (int l.[1], int l.[2])))
    let names = monitoredQuantitiesBounds |> List.map fst
    let chainLength = 
      let (_, (fromIdx, toIdx)) = monitoredQuantitiesBounds.Head 
      toIdx - fromIdx + 1
    let groupedLines = CommonTools.IO.readLines chainFile |> Seq.toList |> CommonTools.List.groupByN chainLength
    let mapping s =
      let items = s |> CommonTools.String.split ["  "]  // Values are separated by two spaces.
      (int items.[0], float items.[1]) 
    let matrix = groupedLines |> CommonTools.LoL.map mapping |> CommonTools.LoL.map snd
    List.zip names matrix |> dict
  [chain1File; chain2File] |> List.map getChains

chains.[0].["theta[1]"] |> FSharp.Charting.Chart.FastLine
chains.[0].["theta[2]"] |> FSharp.Charting.Chart.FastLine
chains.[0].["muTheta"] |> FSharp.Charting.Chart.FastLine
chains.[0].["sigmaTheta"] |> FSharp.Charting.Chart.FastLine
chains.[0].["sigmaY"] |> FSharp.Charting.Chart.FastLine

let drawHistogram numBuckets data = 
  let hist = MathNet.Numerics.Statistics.Histogram(data, numBuckets)
  let buckets = List.init hist.BucketCount (fun i -> hist.Item(i))
  let normConst = float hist.BucketCount / (hist.UpperBound - hist.LowerBound) / float hist.DataCount
  let points = buckets |> List.map (fun b -> (b.LowerBound + b.UpperBound) / 2.0, b.Count * normConst)
  FSharp.Charting.Chart.Column(points)

// Visualization of uniform PDF
let visualizeUniformPDF a b =
  [a, 0.0; a, 1.0 / (b - a); b, 1.0 / (b - a); b, 0.0] |> Chart.Line
// Visualization of Normal PDF
let visualizeNormalPDF mu sigma =
  let interval = 6.0 * sigma
  let numPoints = 100
  let xs = [mu - interval / 2.0 .. interval / float numPoints .. mu + interval / 2.0]
  xs |> List.map (fun x -> x, MathNet.Numerics.Distributions.Normal.PDF(mu, sigma, x)) |> FSharp.Charting.Chart.Line

[chains.[0].["muTheta"] |> drawHistogram 50; visualizeUniformPDF minMuTheta maxMuTheta] |> Chart.Combine
[chains.[0].["sigmaTheta"] |> drawHistogram 50; visualizeUniformPDF minSigmaTheta maxSigmaTheta] |> Chart.Combine
[chains.[0].["sigmaY"] |> drawHistogram 50; visualizeUniformPDF minSigmaY maxSigmaY] |> Chart.Combine

// All all chains of theta together
let allThetas = 
  let mapping i =
    let key = sprintf "theta[%d]" i
    chains.[0].[key]
  [1..numThetaSamples] |> List.map mapping |> List.collect id
allThetas.Length
allThetas |> List.average
allThetas |> CommonTools.Seq.stdDevSample
[allThetas |> drawHistogram 50; visualizeNormalPDF muTheta sigmaTheta] |> Chart.Combine
